phase_1:
gdb进入, disas phase_1 查看反汇编, 发现在判断字符串相等前有条传参指令move 0x... %esi,
合理推断这个内存处的数据就是需要输入的字符串答案, 用x/s 查看就行了 

phase_2:
查看反汇编, phase_2里面有个call read_six_numbers 这里应该就是侧面提示我们这次输入的是6个
数字,继续进去看反汇编,能推断出输入的这六个数字是给存放在栈里, 返回后紧接着就是判断栈顶是否存着$1, 
说明栈顶的数字一定是1, 不然就爆炸了
同样的思路继续看下去，发现有一个循环，每次都能推断出下一个数字是多少，
最终算出答案是 32 16 8 4 1 (-> 栈顶方向)
不过在 read_six_numbers里可以看到，第一个输入的参数是放在高地址处
所以输入顺序是 1 2 4 8 16 32
