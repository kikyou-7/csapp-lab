phase_1:
gdb进入, disas phase_1 查看反汇编, 发现在判断字符串相等前有条传参指令move 0x... %esi,
合理推断这个内存处的数据就是需要输入的字符串答案, 用x/s 查看就行了 

phase_2:
查看反汇编, phase_2里面有个call read_six_numbers 这里应该就是侧面提示我们这次输入的是6个
数字,继续进去看反汇编,能推断出输入的这六个数字是给存放在栈里, 返回后紧接着就是判断栈顶是否存着$1, 
说明栈顶的数字一定是1, 不然就爆炸了
同样的思路继续看下去，发现有一个循环，每次都能推断出下一个数字是多少，
最终算出答案是 32 16 8 4 2 1 (-> 栈顶方向)
不过在 read_six_numbers里 sscanf可以看到，第一个输入的参数是放在栈顶处,也就是低地址处
所以输入顺序是 1 2 4 8 16 32

phase_3:
步入sscanf后能发现这题的答案是2个数字  关键在下面两行代码
<+46>:    mov    0x8(%rsp),%eax #将第一个参数传给eax
<+50>:    jmp    *0x402470(,%rax,8 #跳转到 *(0x402470+8*rax) 所在的指令
*0x402470 查看后发现就是 <+57>
所以这题就很明显了，要凑到这样2个数字, 第一个用来跳转到某处指令，第二个和它给的数字作比较


phase_4:
进入isoc99_sscanf可以看出需要输入两个整数,
可以试出来, rsp+0x8存了输入的第一个参数, rsp+0xc存了输入的第二个参数
进入func4看看做了什么,发现要让func4正确返回,需要第二个参数同时>=7 <=7, 于是知道第二个参数只能等于7
再看到最后 cmpl 0x0, 0xc(rsp) 可以推断出第一个参数就是0x0


phase_5:
首先能猜到我们需要输入一个长度为6的字符串,
需要看出汇编中藏了一个循环, 输入的字符串是用来索引的,
最终将索引到的6个字符, 和它藏的6个字符作比较, 需要相等 