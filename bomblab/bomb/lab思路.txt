phase_1:
gdb进入, disas phase_1 查看反汇编, 发现在判断字符串相等前有条传参指令move 0x... %esi,
合理推断这个内存处的数据就是需要输入的字符串答案, 用x/s 查看就行了 

phase_2:
查看反汇编, phase_2里面有个call read_six_numbers 这里应该就是侧面提示我们这次输入的是6个
数字,继续进去看反汇编,能推断出输入的这六个数字是给存放在栈里, 返回后紧接着就是判断栈顶是否存着$1, 
说明栈顶的数字一定是1, 不然就爆炸了
同样的思路继续看下去，发现有一个循环，每次都能推断出下一个数字是多少，
最终算出答案是 32 16 8 4 2 1 (-> 栈顶方向)
不过在 read_six_numbers里 sscanf可以看到，第一个输入的参数是放在栈顶处,也就是低地址处
所以输入顺序是 1 2 4 8 16 32

phase_3:
这题的答案是2个数字  关键在下面两行代码
<+46>:    mov    0x8(%rsp),%eax #将第一个参数传给eax
<+50>:    jmp    *0x402470(,%rax,8 #跳转到 *(0x402470+8*rax) 所在的指令
*0x402470 查看后发现就是 <+57>
所以这题就很明显了，要凑到这样2个数字, 第一个用来跳转到某处指令，第二个和它给的数字作比较